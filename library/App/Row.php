<?php
/**
 * Default class for all rows in the application
 *
 * Features:
 *
 * 1. Aliases for finding related rows
 *    - overrides the findDependentRowset(), findParentRow() and findManyToManyRowset()
 *      so that they can be called with an alias of the table provided in the referenceMap 
 *      array.
 *
 *      Code example:
 *      
 *      Given the class definition:
 *
 *      class App_Table_TableNames extends App_Table
 *      {
 *          'TableName' => array(
 *              'columns' => 'table_name_id',
 *              'refTableClass' => 'App_Table_TableNames',
 *              'refColumns' => 'id',
 *          ),
 *      }
 *
 *      $tableNamesTable = new App_Table_TableNames();
 *      $row = $tableNamesTable->find(5)->current();
 *      $associatedTableName = $row->findTableName()->current(); // notice the alias
 *
 * 2. Managing dependencies (used in the BackOffice)
 *    - isDeleteable() method should be called to test if a row can be deleted (no other 
 *      objects are linked to it).
 *    - getFormattedDependencies() returns an array with all the unfulfilled dependencies
 *      generated by the last isDeleteable() call
 *    - there is backoffice view file that displays this dependencies, 
 *      application/modules/backoffice/views/partials/default-cannot-delete.phtml
 *
 * 3. The getNameValue() function
 *    - returns this row's value on the nameColumn as defined in its table.
 *
 * @category App
 * @package App_Row
 * @copyright TweetTrendings.com
 */

abstract class App_Row extends Zend_Db_Table_Row_Abstract
{

    /**
     * Holds the unfulfilled dependencies when deleting
     * an object
     * 
     * @var array
     * @access protected
     */
    protected $_unfullfiledDependencies = array();

    /**
     * Checks if the current item is deleteable.
     * Override to add custom logic
     * 
     * @access public
     * @return bool
     */
    public function isDeleteable()
    {
        $dependencies = array();
        foreach($this->getTable()->getDependentTables() as $dependentTable) {
            $rowset = $this->findDependentRowset($dependentTable);
            if (count($rowset)) {
                $dependencies[$dependentTable] = $rowset;
            }
        }

        if (empty($dependencies)) {
            return true;
        }

        $this->_unfullfiledDependencies = $dependencies;
        
        return false;
    }

    /**
     * Returns an array of formatted dependencies for this model
     * 
     * @access public
     * @return void
     */
    public function getFormattedDependencies()
    {
        if (empty($this->_unfullfiledDependencies)) {
            $this->isDeleteable();
        }

        if (empty($this->_unfullfiledDependencies)) {
            return array();
        }

        $inflector = App_Inflector::getInstance();

        $dependencies = array();
        foreach ($this->_unfullfiledDependencies as $table => $rowset) {
            $temp = array();
            foreach ($rowset as $row) {
                $temp []= array(
                    'name' => $row->getNameValue(),
                    'id' => $row->id,
                );
            }
            if (!empty($row)) {
                $dependencies []= array(
                    'class' => $table,
                    'name'  => $inflector->humanizeModelName(get_class($row)),
                    'controller' => $rowset->getTable()->getBackofficeController(),
                    'rows' => $temp,
                );
            }
        }

        return $dependencies;
    }

    /**
     * Gets the value on the $_nameColumn column in defined in the table
     * 
     * @access public
     * @return string
     */
    public function getNameValue()
    {
        return $this->{$this->getTable()->getNameColumn()};
    }

    /**
     * Overrides findDependentRowset() in Zend_Db_Table_Row
     * 
     * @param mixed $dependentTable 
     * @param mixed $ruleKey 
     * @param Zend_Db_Table_Select $select 
     * @access public
     * @return void
     */
    public function findDependentRowset($dependentTable, $ruleKey = null, Zend_Db_Table_Select $select = null)
    {
        $dependentTable = $this->_fixTableName($dependentTable);

        if (null === $select) {
            $select = new Zend_Db_Table_Select(new $dependentTable());
        }

        return parent::findDependentRowset($dependentTable, $ruleKey, $select);
    }


    /**
     * Overrides findParentRow() in Zend_Db_Table_Row
     * 
     * @param mixed $parentTable 
     * @param mixed $ruleKey 
     * @param Zend_Db_Table_Select $select 
     * @access public
     * @return void
     */
    public function findParentRow($parentTable, $ruleKey = null, Zend_Db_Table_Select $select = null)
    {
        $parentTable = $this->_fixTableName($parentTable);

        if (null === $select) {
            $select = new Zend_Db_Table_Select(new $parentTable());
        }

        return parent::findParentRow($parentTable, $ruleKey, $select);
    }

    /**
     * Overrides findManyToManyRowset() in Zend_Db_Table_Row
     * 
     * @param mixed $matchTable 
     * @param mixed $intersectionTable 
     * @param mixed $callerRefRule 
     * @param mixed $matchRefRule 
     * @param Zend_Db_Table_Select $select 
     * @access public
     * @return void
     */
    public function findManyToManyRowset($matchTable, $intersectionTable, $callerRefRule = null, 
                                         $matchRefRule = null, Zend_Db_Table_Select $select = null)
    {
        $matchTable = $this->_fixTableName($matchTable);
        $intersectionTable = $this->_fixTableName($intersectionTable);


        return parent::findManyToManyRowset($matchTable, $intersectionTable, $callerRefRule, $matchRefRule, $select);
    }

    /**
     * Gets the full table name based on an alias
     * 
     * @param mixed $table 
     * @access protected
     * @return void
     */
    protected function _fixTableName($table)
    {
        if (is_string($table)) {
            if (substr($table, 0, 4) == 'App_') {
                return $table;
            }

            if (null === $this->getTable()) {
                throw new Zend_Exception('Please do not use this method on models that are not connected to their tables');
            }

            $temp = $this->getTable()->getAssociationTableByAlias($table);
            if ($temp !== false) {
                return $temp;
            }

            return $table;

        }

        return $table;
    }

    /**
     * Update the timestamps
     *
     * @return void
     */
    protected function _update(){
        if(isset($this->updated_at)){
            $this->updated_at = date('Y-m-d H:i:s');
        }
    }
    
    /**
     * Update the timestamps
     *
     * @return void
     */
    protected function _save(){
        if(isset($this->created_at)){
            $this->created_at = date('Y-m-d H:i:s');
        }
    }
    
    /**
     * Remove a file from the CDN and S3
     *
     * @return void
     */
    public function removeFromCDN(){
        //Remove from S3
        App_DI_Container::get('S3StorageEngine')->deleteItem(
            $this->filename, 
            array(
                Zend_Cloud_StorageService_Adapter_S3::BUCKET_NAME => App_DI_Container::get('ConfigObject')->amazon->s3->assets_bucket
            )
        );
        
        //Invalidate the image in the CDN
        if(!App_DI_Container::get('CloudFront')->invalidate($this->filename)){
            App_Logger::log(sprintf('Error removing %s from CDN', $this->filename), Zend_Log::ERR);
        }
    }
}